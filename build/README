# Build

## Usage

    build.py TEMPLATE_FILE [OUTPUT_FILE]

## Parameters

    TEMPLATE_FILE   -   the template from which to produce output file (see
                        syntax below).
    
    OUTPUT_FILE     -   the file to write output to.
    
## Template file syntax

Any plaintext file could be a valid template file however without the following
syntax, the output will generally be identity.

A template file should commence with the line exactly matching `::TEMPLATE;`
however some implementations may not require this or produce a warning if not
present. A comment following the semicolon should also be allowed (and ignored)
by model implementations. In order to comply with shebang, if the first line
commences with a `#`, it will be ignored and the second line shall be
`::TEMPLATE;`. This is a special case, all other `#` commencing lines will be
preserved in the output. This means that an executable (shebang) template to
produce an executable (shebang) script could commence as:

    `#! /path/to/build.py
     ::TEMPLATE; to build executable script
     #! /path/to/interpreter`

It is also recomended that template files use the file extension `.template`
however this is not mandated. A consitant style for file extensions should be
used within a project.

### General Syntax

The following syntax is available throughout the template file:

1. Any line commencing with the `\` character (preceeded only by whitespace)
   is treated as a literal line, the `\` is stripped however the whitespace
   (if any) is preserved.
   
        `    \:This is a line commencing with four spaces and a colon.`
        ->
        `    :This is a line commencing with four spaces and a colon.`
        
        `\\This is a line commencing with a back slash.`
        ->
        `\This is a line commencing with a backslash.`
        
        `\\:This is a line commencing with a back slash and a colon.`
        ->
        `\:This is a line commencing with a back slash and a colon.`

   Note that the `\` character only has a special meaning at the beginning of
   a line. It is not a general escape character in the template syntax.
   
2. Any line commencing with the `:` character (preceeded only by whitespace)
   is treated as a command. If an output line needs to commence with a `:`, it
   should be escaped with a `\`. Commands must reside on a single line and
   consume the entire line. Commands must be closed with the `;` character.
   Command lines not containing a `;` will raise a warning or an error
   depending on implementation, context and other parameters. Anything
   following the first `;` on a command line is ignored and this space should
   be used for comments. An empty command `:;` can be used to insert a comment
   where no command is issued. The whitespace indent preceeding a command is
   ignored and context whitespace must be generated by the command.
   
        `:;This line is just a comment, nothing will be echoed to the output.`
    
        `    :command;This line will be replaced by the output of "command".`

   Note that commands which fail may do so silently or they may raise a
   warning or an error depending on implementation, context and other
   parameters.

3. Any line whose first (non-whitespace) character is neither the `:` nor the
   `\` character will be echoed to the output verbatim.

### Command Syntax

The following command types are available:

1. `::DECLARATION;`     -   As the first line of a file, declares the file
                            type. Recognized values are: `::TEMPLATE;`,
                            `::FRAGMENT;` and `::PARAMETRIC;`. Elsewhere in
                            the file, declares properties of the file.
                            Recognized values are evolving and depend on
                            context and file type. Declaration commands
                            commence with two `:` characters (rather than the
                            usual one) and should be in allcaps style
                            (containing only capital letters, digits and `_`,
                            not commencing with a digit).

2. `:[path/to/]fragment;`
            -   This line shall be substituted by the verbatim contents
                (excluding the declaration line) of
                `[path/to/]fragment.fragment` or `[path/to/]fragment` if the
                former isn't found. This command will fail if neither file is
                found and may fail if the file is not declared as a
                `::FRAGMENT;`. Fragment files do not provide any recursive 
                command parsing. Fragment file names should tend towards lower
                case styles but may contain any valid file path characters.

3. `:[path/to/]parametric();`
            -   This line shall be substituted by the parsed contents of
                `[path/to/]parametric.parametric` or `[path/to/]parametric` if
                the former isn't found. This command will fail if neither file
                is found and may fail if the file is not declared as a
                `::PARAMETRIC;`. Parametric files are like fragment files but
                may contain parameters which can be substituted via assignment
                between the parentheses where it is invoked in the template
                file. Parameters may be optional or required and default
                values may be specified by the parametric file. Where required
                parameters are not provided at invocation, this will raise a
                warning or an error depending on implementation, context and
                other parameters. Parametric assignment is similar to Pythonic
                keyword argument syntax `(PARAM0=val0, PARAM1=val1 ...)`.
                Parametric files should tend towards lower case styles but may
                contain any valid file path characters.

### Parametric File Syntax

Parametric files are exactly like fragment files (which are exactly like
plaintext files except for the `::FRAGMENT;` declaration) except that they are
declared with `::PARAMETRIC;` and the may contain substitution parameters.
The following syntax is available in parametric files:

1. `<[PARAM_NAME]>`
        -   May occur anywhere in the file but must be contained on a single
            line in each instance. It will - by default - be substituted for
            the value bound to `PARAM_NAME` at invocation from a template
            file. Each `PARAM_NAME` may appear any number of times in the
            file. The default behaviour (if not otherwise declared) is for
            parameters not mapped at invocation to raise a warning and default
            to an empty substitution. To modify this behaviour, a declaration
            for the parameter is required. It is recomended that parameter
            names should be in allcaps style.

2. `::PARAM:PARAM_NAME[:[REQUIRED][:DEFAULT_VAL]];`
        -   This is the standard syntax for a parameter declaration. All
            parameter declarations should occur at the top of the file,
            immediately following the file declaration. The parameter
            declaration syntax contains a number of standard components:
                1. `::PARAM` is literal, specifies that this is a parameter
                   declaration.
                2. `:PARAM_NAME` specifies the name of the parameter being
                   declares. `PARAM_NAME` should exactly match the
                   `PARAM_NAME` from the `<[PARAM_NAME]>` tokens.
                3. `:REQUIRED` is a boolean (True|False) specifying if the
                   parameter must be bound at invocation. This component is
                   not required, its value may be implied (or even overwriten)
                   by the next component.
                4. `:DEFAULT_VAL` specifies the default value to bind to
                   `PARAM_NAME` if not provided by the invocation in the
                   template file. Note that if this component is present then
                   at least the leading `:` from the previous component must
                   be present.
                5. `;` the declaration must be closed with a semicolon.
            If neither `REQUIRED` nor `DEFAULT_VAL` are set, the declaration
            does not change the default behaviour however the warning will be
            raised whether or not the parameter occurs in the body of the
            parametric file. If only `REQUIRED` is set, the template
            invocation will fail if the parameter is not bound. If only
            `DEFAULT_VAL` is set, `REQUIRED` is set to `False`. If both
            `REQUIRED` and `DEFAULT_VAL` are set and `REQUIRED` is `True`, it
            will raise only a warning (not the usual error) if the invocation
            fails to bind `PARAM_NAME` and the invocation will succeed
            (notwithstanding other errors). Example behaviour when unbound at
            invocation:
                `::PARAM:A;`            -> Bind `""` to `<[A]>` with unbound
                                           warning.
                `::PARAM:B:True;`       -> Fail with unbound error.
                `::PARAM:C:False;`      -> Silently bind `""` to `<[C]>`.
                `::PARAM:D::foo;`       -> Silently bind `"foo"` to `<[D]>`.
                `::PARAM:E:True:bar`    -> Bind `"bar"` to `<[E]>` with
                                           unbound warning.
                `::PARAM:F:False:baz`   -> Silently bind `"baz"` to `<[F]>`.

3. `\`  -   As with the template format, a line commencing with a backslash is
            treated as literal with the leading slash stripped. In this way, a
            literal line commencing with `:` or `\` can be achieved by
            pre-appending a backslash. In parametric files, the backslash can
            also be used to escape a single parameter token (or rather it can
            be used to escape the opening of a parameter token, e.g. `\<[A]>`
            will output the literal `<[A]>` without attempting to perform
            substitution. Note that `\` only performs an escape when the
            following character or group could have a special meaning so `\\x`
            is the same as `\x` so long as `x` is a literal sequence.
            Examples:
                `::PARAM:X;`        ->  No output but parameter `X` declared.
                `\::PARAM:X;`       ->  `::PARAM:X;`.
                `\\::PARAM:X;`      ->  `\::PARAM:X;`.
                `\text`             ->  `text`.
                `\\text`            ->  `\text`.
                `text <[A]> text`   ->  `text VALUE_BOUND_TO_A text`.
                `\:text <[A]> text` ->  `:text VALUE_BOUND_TO_A text`.
                `\\text <[A]> text` ->  `\text VALUE_BOUND_TO_A text`.
                `text \<[A]> <[B]>` ->  `text <[A]> VALUE_BOUND_TO_B`.
                `text \\<[A]>`      ->  `text \VALUE_BOUND_TO_A`.
                `text \\\<[A]>`     ->  `text \<[A]>`.
                `text \<[<[A]>]>`   ->  `text <[VALUE_BOUND_TO_A]>`.
